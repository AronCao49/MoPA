import torch
import numpy as np


def refine_pseudo_labels(probs, pseudo_label, ignore_label=-100):
    """
    Reference: https://github.com/liyunsheng13/BDL/blob/master/SSL.py
    Per class, set the less confident half of labels to ignore label.
    :param probs: maximum probabilities (N,), where N is the number of 3D points
    :param pseudo_label: predicted label which had maximum probability (N,)
    :param ignore_label:
    :return:
    """
    probs, pseudo_label = torch.tensor(probs), torch.tensor(pseudo_label)
    for cls_idx in pseudo_label.unique():
        curr_idx = pseudo_label == cls_idx
        curr_idx = torch.nonzero(curr_idx).squeeze(1)
        thresh = probs[curr_idx].median()
        thresh = min(thresh, 0.9)
        ignore_idx = curr_idx[probs[curr_idx] < thresh]
        pseudo_label[ignore_idx] = ignore_label
    return pseudo_label.numpy()


def refine_sam_2Dlabels(
    probs: np.ndarray,
    img_indices: np.ndarray, 
    sam_mask: np.ndarray,
    max_area_thre: float = 0.1
    ) -> np.ndarray:
    """Function to refine 2D pseudo labels throguh SAM mask

    Args:
        probs (np.ndarray): maximum probabilities (N, C)
        img_indices (np.ndarray): x, y indices for each prob (N, 2)
        sam_mask (np.ndarray): mask generated by SAM (H, W)
        max_area_thre (float): the maximum allowed area of mask

    Returns:
        np.ndarray: 2D pseudo labels of image size (H, W)
    """
    probs = torch.from_numpy(probs).float()
    img_indices = torch.from_numpy(img_indices).int().long()
    sam_mask = torch.from_numpy(sam_mask)
    full_2d_probs = torch.zeros(
        [sam_mask.shape[0], sam_mask.shape[1], probs.shape[1]])
    full_2d_pslabels = torch.ones_like(sam_mask).int() * -100
    
    # Refine 2D point labels
    refined_2d_labels = torch.from_numpy(
        refine_pseudo_labels(probs.max(1)[0], probs.argmax(1))).int()
    unreliable_mask = refined_2d_labels <= -100
    probs[unreliable_mask, :] = 0.0
    # Add point probs to image probs
    full_2d_pslabels[img_indices[:, 0], img_indices[:, 1]] = refined_2d_labels
    full_2d_probs[img_indices[:, 0], img_indices[:, 1], :] = probs
    
    mask_ids, id_count = torch.unique(sam_mask, return_counts=True)
    sorted_indices = torch.argsort(id_count, descending=True)
    mask_ids = mask_ids[sorted_indices]
    for mask_id in torch.unique(mask_ids):
        mask = sam_mask == mask_id
        if torch.sum(mask) >= max_area_thre * (sam_mask.shape[0] * sam_mask.shape[1]):
            continue
        mask_preds = full_2d_probs[mask]
        mask_preds = mask_preds.view(-1, mask_preds.shape[-1]).sum(0).argmax(0)
        full_2d_pslabels[mask] = mask_preds.int()
        
    return full_2d_pslabels.numpy()


def refine_sam_mask(
    sam_mask: np.ndarray,
    max_area_thre: float = 0.1,
    max_h: int = None,
    ) -> np.ndarray:
    """Function to refine SAM mask, preseve 

    Args:
        sam_mask (np.ndarray): mask generated by SAM (H, W)
        max_area_thre (float): the maximum allowed area of mask
        max_h (int, optional): maximum height of point_img. None by default.

    Returns:
        np.ndarray: 2D pseudo labels of image size (H, W)
    """
    sam_mask = torch.from_numpy(sam_mask).int()
    
    mask_ids, id_count = torch.unique(sam_mask, return_counts=True)
    sorted_indices = torch.argsort(id_count, descending=True)
    mask_ids = mask_ids[sorted_indices]
    for mask_id in torch.unique(mask_ids):
        mask = sam_mask == mask_id
        if torch.sum(mask) >= max_area_thre * (sam_mask.shape[0] * sam_mask.shape[1]):
            sam_mask[mask] = -100
    
    # Crop out mask that out of lidar FOV:
    if max_h is not None:
        h_limit = sam_mask.shape[0] - max_h
        sam_mask[:h_limit, :] = -100 
        
    return sam_mask.numpy()


def refine_negative_voxels(
    probs: torch.Tensor, 
    pseudo_label: torch.Tensor, 
    ):
    """Function to filter out inconfident voxels

    Args:
        probs (torch.Tensor): Scores of voxels.
        pseudo_label (torch.Tensor): One-hot labels of voxels.

    Returns:
        _type_: _description_
    """
    conf_mask = torch.ones_like(pseudo_label, dtype=torch.bool)
    for cls_idx in pseudo_label.unique():
        curr_idx = pseudo_label == cls_idx
        curr_idx = torch.nonzero(curr_idx).squeeze(1)
        thresh = probs[curr_idx].median()
        thresh = min(thresh, 0.9)
        ignore_idx = curr_idx[probs[curr_idx] < thresh]
        conf_mask[ignore_idx] = False
    return conf_mask